# ğŸ“– Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø®Ø±Ø¬Ø§Øª ÙˆØ§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„Ø§Øª
# SAQR Seeker / CANphon Reference Manual

**Ø§Ù„Ø¥ØµØ¯Ø§Ø±**: 1.0  
**Ø§Ù„ØªØ§Ø±ÙŠØ®**: 2026-01-12  
**Ø§Ù„Ù…Ø´Ø±ÙˆØ¹**: SAQR Seeker - Ù†Ø¸Ø§Ù… Ø§Ù„ØªØªØ¨Ø¹ ÙˆØ§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø±ÙˆØ¨ÙˆØªÙŠ

---

# ÙÙ‡Ø±Ø³ Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª

1. [Ù…Ù‚Ø¯Ù…Ø© Ø¹Ø§Ù…Ø©](#Ø§Ù„ÙØµÙ„-1-Ù…Ù‚Ø¯Ù…Ø©-Ø¹Ø§Ù…Ø©)
2. [Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª (Inputs)](#Ø§Ù„ÙØµÙ„-2-Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª-inputs)
3. [Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª (Outputs)](#Ø§Ù„ÙØµÙ„-3-Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª-outputs)
4. [Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„Ø§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©](#Ø§Ù„ÙØµÙ„-4-Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„Ø§Øª-Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©)
5. [Ù…Ø®Ø·Ø·Ø§Øª Ø§Ù„ØªØ¯ÙÙ‚](#Ø§Ù„ÙØµÙ„-5-Ù…Ø®Ø·Ø·Ø§Øª-Ø§Ù„ØªØ¯ÙÙ‚)
6. [Ø§Ù„Ù…Ù„Ø§Ø­Ù‚](#Ø§Ù„Ù…Ù„Ø§Ø­Ù‚)

---

# Ø§Ù„ÙØµÙ„ 1: Ù…Ù‚Ø¯Ù…Ø© Ø¹Ø§Ù…Ø©

## 1.1 Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù…

Ù†Ø¸Ø§Ù… **SAQR Seeker** Ù‡Ùˆ Ø¥Ø·Ø§Ø± Ø¹Ù…Ù„ Ø±ÙˆØ¨ÙˆØªÙŠ Ø¹Ø³ÙƒØ±ÙŠ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙŠØ¹Ù…Ù„ Ø¨Ù…Ø¹Ù…Ø§Ø±ÙŠØ© **"Ø§Ù„Ù‡Ø§ØªÙ ÙƒØ¹Ù‚Ù„" (Smartphone-as-Brain)**. ÙŠØ³ØªØ®Ø¯Ù… Ù‡Ø§ØªÙ Android ÙƒÙˆØ­Ø¯Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø±ÙƒØ²ÙŠØ© Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø£Ù‡Ø¯Ø§ÙØŒ Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ…Ø±ØŒ ÙˆØ§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¯Ù‚ÙŠÙ‚ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙÙˆÙ‡Ø§Øª ÙˆØ§Ù„Ø¬ÙŠÙ…Ø¨Ø§Ù„.

### Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:
- **YOLOv8**: ÙƒØ´Ù Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
- **ByteTrack**: ØªØªØ¨Ø¹ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
- **Kalman Filter**: ØªÙ†Ø¨Ø¤ Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
- **PID Controller**: ØªØ­ÙƒÙ… Ø¯Ù‚ÙŠÙ‚ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹
- **CAN/Serial Bus**: Ø§ØªØµØ§Ù„ Ù…Ø¹ Ø§Ù„Ø³ÙŠØ±ÙÙˆÙ‡Ø§Øª

## 1.2 Ù…Ø¹Ù…Ø§Ø±ÙŠØ© "Ø§Ù„Ù‡Ø§ØªÙ ÙƒØ¹Ù‚Ù„"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ğŸ“± Android Brain                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Sensors  â”‚â†’ â”‚ AI/ML    â”‚â†’ â”‚ Tracking â”‚â†’ â”‚ PID Control  â”‚    â”‚
â”‚  â”‚ Input    â”‚  â”‚ Detectionâ”‚  â”‚ Engine   â”‚  â”‚ + Decision   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“                                              â†“
   ğŸ“¡ Telemetry                                   âš™ï¸ Actuators
   (Python GCS)                                   (Servos/Motors)
```

## 1.3 Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ø§Ù„Ø¹Ø³ÙƒØ±ÙŠ

| Ø§Ù„Ù…ÙŠØ²Ø© | Ø§Ù„Ø­Ø§Ù„Ø© | Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª |
|--------|--------|-----------|
| Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø·Ø¨Ù‚ÙŠØ© | âœ… | 4 Ø·Ø¨Ù‚Ø§Øª Ø¯Ù…Ø¬ |
| Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù‡Ø¬ÙŠÙ† | âœ… | ByteTrack + Kalman |
| Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹Ø±ÙŠÙ | âœ… | Color-based Re-ID |
| Human-in-Loop | âœ… | Ø¥Ù„Ø²Ø§Ù…ÙŠ Ù„Ù„Ø§Ø´ØªØ¨Ø§Ùƒ |
| Ø¯Ù…Ø¬ Ø­Ø³Ø§Ø³Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© | âœ… | Camera 70% + IMU 20% + GPS 10% |

---

# Ø§Ù„ÙØµÙ„ 2: Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª (Inputs)

## 2.1 Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (CameraX)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ø¯Ù‚Ø©** | 1080p (1920Ã—1080) Ø£Ùˆ 720p (1280Ã—720) |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª** | 30 FPS |
| **Ø§Ù„ØªÙ†Ø³ÙŠÙ‚** | YUV_420_888 |
| **Ø§Ù„Ù…ÙƒØªØ¨Ø©** | Android CameraX |
| **Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©** | `STRATEGY_KEEP_ONLY_LATEST` |

### ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
```kotlin
data class CameraFrame(
    val imageProxy: ImageProxy,      // Ø¥Ø·Ø§Ø± YUV
    val timestamp: Long,             // Ø§Ù„ÙˆÙ‚Øª Ø¨Ø§Ù„Ù†Ø§Ù†Ùˆ Ø«Ø§Ù†ÙŠØ©
    val rotationDegrees: Int,        // 0, 90, 180, 270
    val width: Int,                  // 1920 Ø£Ùˆ 1280
    val height: Int                  // 1080 Ø£Ùˆ 720
)
```

### Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
- **Ø§Ù„ÙƒØ´Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ**: Ø¥Ø·Ø§Ø± ÙˆØ§Ø­Ø¯ ÙƒÙ„ 3-10 Ø¥Ø·Ø§Ø±Ø§Øª
- **Ø§Ù„ØªØªØ¨Ø¹**: ÙƒÙ„ Ø¥Ø·Ø§Ø± (30 Hz)
- **Ø§Ù„ØªØ³Ø¬ÙŠÙ„**: MP4 Ø¨Ø¯Ù‚Ø© ÙƒØ§Ù…Ù„Ø©

---

## 2.2 Ø§Ù„Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨ ÙˆØ§Ù„ØªØ³Ø§Ø±Ø¹ (IMU)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ù…ØµØ¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª** | Android Sensor API |
| **Ù†ÙˆØ¹ Ø§Ù„Ø­Ø³Ø§Ø³** | `TYPE_GYROSCOPE` + `TYPE_ACCELEROMETER` |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª** | 100+ Hz (`SENSOR_DELAY_GAME`) |
| **Ø§Ù„ÙˆØ­Ø¯Ø§Øª** | rad/s (Gyro) | m/sÂ² (Accel) |

### ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
```kotlin
data class IMUData(
    val gyroX: Float,    // rad/s - Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø­ÙˆÙ„ X
    val gyroY: Float,    // rad/s - Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø­ÙˆÙ„ Y
    val gyroZ: Float,    // rad/s - Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø­ÙˆÙ„ Z
    val accelX: Float,   // m/sÂ² - Ø§Ù„ØªØ³Ø§Ø±Ø¹ Ø¹Ù„Ù‰ X
    val accelY: Float,   // m/sÂ² - Ø§Ù„ØªØ³Ø§Ø±Ø¹ Ø¹Ù„Ù‰ Y
    val accelZ: Float,   // m/sÂ² - Ø§Ù„ØªØ³Ø§Ø±Ø¹ Ø¹Ù„Ù‰ Z
    val timestamp: Long  // Ù†Ø§Ù†Ùˆ Ø«Ø§Ù†ÙŠØ©
)
```

### Ø§Ù„ÙˆØ¸ÙŠÙØ©
- **ØªØ¹ÙˆÙŠØ¶ Ø§Ù„Ø§Ù‡ØªØ²Ø§Ø²**: ØªØ«Ø¨ÙŠØª Ø§Ù„ØµÙˆØ±Ø©/Ø§Ù„ØªØªØ¨Ø¹
- **ÙƒØ´Ù Ø§Ù„Ù…ÙŠÙ„Ø§Ù†**: ØªØ­Ø¯ÙŠØ¯ ÙˆØ¶Ø¹ÙŠØ© Ø§Ù„Ø¬Ù‡Ø§Ø²
- **Grace Period**: Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØªØ¨Ø¹ Ø¹Ù†Ø¯ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ù‡Ø¯Ù Ù…Ø¤Ù‚ØªØ§Ù‹

---

## 2.3 GPS Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ (Android Location)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ù…ØµØ¯Ø±** | Android Location Manager |
| **Ø§Ù„Ø¯Ù‚Ø©** | 3-10 Ø£Ù…ØªØ§Ø± (Ø­Ø³Ø¨ Ø§Ù„Ø¸Ø±ÙˆÙ) |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«** | 1-10 Hz |
| **Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©** | `ACCESS_FINE_LOCATION` |

### ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
```kotlin
data class PhoneGPSData(
    val latitude: Double,      // Ø®Ø· Ø§Ù„Ø¹Ø±Ø¶
    val longitude: Double,     // Ø®Ø· Ø§Ù„Ø·ÙˆÙ„
    val altitude: Double,      // Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ (Ù…ØªØ±)
    val speed: Float,          // Ø§Ù„Ø³Ø±Ø¹Ø© (Ù…/Ø«)
    val bearing: Float,        // Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ø¯Ø±Ø¬Ø©)
    val accuracy: Float,       // Ø¯Ù‚Ø© Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Ù…ØªØ±)
    val satellites: Int,       // Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ù‚Ù…Ø§Ø±
    val timestamp: Long        // Ø§Ù„ÙˆÙ‚Øª
)
```

---

## 2.4 GPS Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ (KCA Serial)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ø§ØªØµØ§Ù„** | USB Serial (RS232-to-TTL) |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙˆØ¯** | 115200 bps |
| **Ø­Ø¬Ù… Ø§Ù„Ø­Ø²Ù…Ø©** | 164 Ø¨Ø§ÙŠØª |
| **Ø§Ù„Ø¯Ù‚Ø©** | 0.5-2 Ù…ØªØ± (Multi-Constellation) |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«** | 10 Hz |

### Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø­Ø²Ù…Ø© (164 Ø¨Ø§ÙŠØª)
| Ø§Ù„Ø¨Ø§ÙŠØª | Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„ÙˆØµÙ |
|--------|-------|-------|
| 0 | Sync 1 | `0x81` |
| 1 | Sync 2 | `0x7E` |
| 2-161 | NavData | 160 Ø¨Ø§ÙŠØª Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù„Ø§Ø­Ø© |
| 162-163 | CRC | CRC-16 CCITT |

### Ø­Ù‚ÙˆÙ„ NavData Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
| Ø§Ù„Ù…ÙˆÙ‚Ø¹ | Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„Ù†ÙˆØ¹ | Ø§Ù„ÙˆØµÙ |
|--------|-------|-------|-------|
| 1 | State | uint8 | Ø­Ø§Ù„Ø© Ø§Ù„Ù€ Fix (0=ØºÙŠØ± Ø¬Ø§Ù‡Ø²ØŒ 1+=ØµØ§Ù„Ø­) |
| 72-75 | Latitude | float | Ø®Ø· Ø§Ù„Ø¹Ø±Ø¶ |
| 76-79 | Longitude | float | Ø®Ø· Ø§Ù„Ø·ÙˆÙ„ |
| 80-83 | Altitude | float | Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ |
| 90-101 | Velocity | float[3] | $V_x, V_y, V_z$ ECEF |
| 131-135 | DOPs | uint8[5] | GDOP, PDOP, HDOP, VDOP, TDOP |

### Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
```
Header: 81 7E
State: 03 (3D Fix)
Latitude: 24.7136Â° N
Longitude: 46.6753Â° E
Altitude: 612.5 m
Satellites: 12
HDOP: 0.8
CRC: Valid âœ“
```

---

## 2.5 Ø§Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ø±Ø§Ø¬Ø¹Ø© Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙÙˆ (Servo Feedback)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„** | STM32 Unified 7-Byte |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙˆØ¯** | 115200 bps |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«** | 50-100 Hz |
| **Ø§Ù„Ø¯Ù‚Ø©** | 0.025Â° |

### Ù‡ÙŠÙƒÙ„ Ø­Ø²Ù…Ø© Ø§Ù„ÙÙŠØ¯Ø¨Ø§Ùƒ (7 Ø¨Ø§ÙŠØª)
| Ø§Ù„Ø¨Ø§ÙŠØª | Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„ÙˆØµÙ |
|--------|-------|-------|
| 0 | Sync+ID_H | `0x80 | OpCode | (ID>>7 & 0x03)` |
| 1 | ID_Low | `ID & 0x7F` |
| 2 | Data_H | Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù„ÙŠØ§ |
| 3 | Data_L | Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ù†ÙŠØ§ |
| 4 | Extra1 | Ù…Ø­Ø¬ÙˆØ² |
| 5 | Extra2 | Ù…Ø­Ø¬ÙˆØ² |
| 6 | Checksum | `((XOR 0..5) & 0x7F) | 0x40` |

### ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
```kotlin
// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø®Ø§Ù… Ø¥Ù„Ù‰ Ø²Ø§ÙˆÙŠØ©
val rawPosition = (byte2 * 128) + byte3
val angleDegrees = (rawPosition - 8191) * 0.025f

// ØªØ­ÙˆÙŠÙ„ Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©
val rawTemp = (byte2 * 128) + byte3
val tempCelsius = (rawTemp - 8191) * 0.1f
```

---

## 2.6 Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (User Input)

### Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù„Ù…Ø³
| Ø§Ù„Ø­Ø¯Ø« | Ø§Ù„ÙˆØ¸ÙŠÙØ© |
|-------|---------|
| **Ù†Ù‚Ø±Ø© ÙˆØ§Ø­Ø¯Ø©** | ØªØ­Ø¯ÙŠØ¯ Ù‡Ø¯Ù Ø¬Ø¯ÙŠØ¯ |
| **Ù†Ù‚Ø±Ø© Ù…Ø²Ø¯ÙˆØ¬Ø©** | Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØªØ¨Ø¹ |
| **Ø³Ø­Ø¨** | ØªØ­Ø±ÙŠÙƒ ÙŠØ¯ÙˆÙŠ Ù„Ù„Ø¬ÙŠÙ…Ø¨Ø§Ù„ |
| **Ø¶ØºØ· Ù…Ø·ÙˆÙ„** | Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ù‡Ø¯Ù |

### Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªØ­ÙƒÙ…
```kotlin
data class ControlCommand(
    val throttle: Int,    // 0-1000
    val roll: Int,        // -500 to +500
    val pitch: Int,       // -500 to +500
    val yaw: Int          // -500 to +500
)
```

---

# Ø§Ù„ÙØµÙ„ 3: Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª (Outputs)

## 3.1 Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø³ÙŠØ±ÙÙˆ - CAN Bus

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„** | XQPOWER v022 |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙˆØ¯** | 2 Mbps |
| **Ø§Ù„Ù…Ø­ÙˆÙ„** | Waveshare USB-CAN-A (VID: 0x1A86) |
| **Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ø§ÙˆÙŠØ©** | -100.0Â° Ø¥Ù„Ù‰ +100.0Â° |
| **Ø§Ù„Ø¯Ù‚Ø©** | 0.1Â° |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„** | 50 Hz |

### Ù‡ÙŠÙƒÙ„ Ø¥Ø·Ø§Ø± CAN
```
[HEAD: 0xAA][ID_LOW][ID_HIGH][DLC][DATA_0..7][CHECKSUM]
```

### Ø£ÙˆØ§Ù…Ø± XQPOWER
| Ø§Ù„Ø£Ù…Ø± | Ø§Ù„ÙˆØ¸ÙŠÙØ© | Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª |
|-------|---------|----------|
| `0x01` | ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…ÙˆÙ‚Ø¹ | Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ã— 10 (int16) |
| `0x02` | ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø³Ø±Ø¹Ø© | RPM Ã— 10 |
| `0x05` | Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ÙÙŠØ¯Ø¨Ø§Ùƒ | Ø§Ù„Ù…ÙˆÙ‚Ø¹ + Ø§Ù„Ø³Ø±Ø¹Ø© + Ø§Ù„Ø­Ø±Ø§Ø±Ø© |

### Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø£Ù…Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹
```kotlin
// ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø³ÙŠØ±ÙÙˆ ID=601 Ø¥Ù„Ù‰ Ø²Ø§ÙˆÙŠØ© 45.5Â°
val angleValue = (45.5 * 10).toInt()  // = 455
// CAN Frame: [0xAA][0x59][0x02][0x02][0xC7][0x01][CS]
```

---

## 3.2 Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø³ÙŠØ±ÙÙˆ - Serial (STM32 5-Byte)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø­Ø¬Ù… Ø§Ù„Ø­Ø²Ù…Ø©** | 5 Ø¨Ø§ÙŠØª |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙˆØ¯** | 115200 bps |
| **Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ø§ÙˆÙŠØ©** | -25.0Â° Ø¥Ù„Ù‰ +25.0Â° |
| **Ø§Ù„Ø¯Ù‚Ø©** | 0.025Â° (14-bit) |
| **Ø§Ù„ÙˆØ­Ø¯Ø§Øª Ù„ÙƒÙ„ Ø¯Ø±Ø¬Ø©** | 40.0 |
| **Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø­Ø§ÙŠØ¯Ø© (0Â°)** | 8191 |

### Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø­Ø²Ù…Ø© (5 Ø¨Ø§ÙŠØª)
| Ø§Ù„Ø¨Ø§ÙŠØª | Ø§Ù„Ø§Ø³Ù… | Ø§Ù„Ù…Ù†Ø·Ù‚ |
|--------|-------|--------|
| 0 | Sync+OpCode | `0x80 | 0x08 | ((servoId >> 7) & 0x03)` |
| 1 | ID | `servoId & 0x7F` |
| 2 | Hpos | `(position >> 7) & 0x7F` |
| 3 | Lpos | `position & 0x7F` |
| 4 | Checksum | `(Byte0 ^ Byte1 ^ Byte2 ^ Byte3) & 0x7F` |

### ØµÙŠØºØ© Ø§Ù„ØªØ­ÙˆÙŠÙ„
```kotlin
// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø¥Ù„Ù‰ Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ÙˆÙ‚Ø¹
fun angleToPosition(angleDegrees: Float): Int {
    return ((angleDegrees * 40.0f) + 8191).toInt()
        .coerceIn(0, 16383)
}

// Ù…Ø«Ø§Ù„: 10Â° â†’ Position = (10 * 40) + 8191 = 8591
```

### Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø­Ø²Ù…Ø©
```
// ØªØ­Ø±ÙŠÙƒ Servo ID=1 Ø¥Ù„Ù‰ 10Â°
Position = 8591 = 0x218F
Byte0 = 0x88  (0x80 | 0x08 | 0x00)
Byte1 = 0x01  (ID)
Byte2 = 0x43  ((8591 >> 7) & 0x7F = 67)
Byte3 = 0x0F  (8591 & 0x7F = 15)
Byte4 = 0x45  (XOR checksum)

Packet: [88 01 43 0F 45]
```

---

## 3.3 Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚ÙŠØ§Ø³ (Telemetry) - 73 Ø¨Ø§ÙŠØª

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø­Ø¬Ù… Ø§Ù„Ø­Ø²Ù…Ø©** | 73 Ø¨Ø§ÙŠØª |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙˆØ¯** | 115200 bps |
| **Ø§Ù„Ù…Ø­ÙˆÙ„** | FTDI USB-Serial (VID: 0x0403) |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„** | 60 Hz |
| **ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª** | Little Endian |

### Ø¬Ø¯ÙˆÙ„ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø­Ø²Ù…Ø© Ø§Ù„ÙƒØ§Ù…Ù„
| Ø§Ù„Ù…ÙˆÙ‚Ø¹ | Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„Ø­Ø¬Ù… | Ø§Ù„Ù†ÙˆØ¹ | Ø§Ù„ÙˆØµÙ |
|--------|-------|-------|-------|-------|
| **0** | Header 1 | 1B | byte | `0xAA` |
| **1** | Header 2 | 1B | byte | `0x55` |
| **2** | Length | 1B | uint8 | `70` (Ø§Ù„Ø·ÙˆÙ„ Ø¨Ø¯ÙˆÙ† Ø§Ù„Ù‡ÙŠØ¯Ø±) |
| **3-6** | Timestamp | 4B | uint32 | Ø§Ù„ÙˆÙ‚Øª Ø¨Ø§Ù„Ù…ÙŠÙ„ÙŠ Ø«Ø§Ù†ÙŠØ© |
| **7-12** | Orientation | 6B | int16[3] | Roll, Pitch, Yaw (Ø¯Ø±Ø¬Ø© Ã— 10) |
| **13-18** | Acceleration | 6B | int16[3] | X, Y, Z (Ù…/Ø«Â² Ã— 100) |
| **19-22** | Pressure | 4B | mixed | Ø§Ù„Ø¶ØºØ· (hPa) + Ø§Ø±ØªÙØ§Ø¹ Ø¨Ø§Ø±Ùˆ (Ù… Ã— 10) |
| **23-40** | GPS Data | 18B | mixed | Lat/Lon/Alt/Spd/Hdg/Sats/Fix/HDOP |
| **41-48** | Servo Cmds | 8B | int16[4] | Ø£ÙˆØ§Ù…Ø± S1-S4 (Ø¯Ø±Ø¬Ø© Ã— 10) |
| **49-56** | Servo FB | 8B | int16[4] | ÙÙŠØ¯Ø¨Ø§Ùƒ S1-S4 (Ø¯Ø±Ø¬Ø© Ã— 10) |
| **57** | Servo Status | 1B | bitmask | bit0=S1 online, etc. |
| **58-65** | Tracking | 8B | mixed | Target X, Y, Width, Height |
| **66-69** | Battery | 4B | mixed | %, Charging, Voltage (mV) |
| **70-71** | Temperature | 2B | int16 | Ø³ÙŠÙ„Ø³ÙŠÙˆØ³ Ã— 10 |
| **72** | Checksum | 1B | byte | XOR Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª 0-71 |

### Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ù€ Checksum
```kotlin
fun calculateChecksum(data: ByteArray): Byte {
    var checksum: Byte = 0
    for (i in 0 until data.size - 1) {
        checksum = (checksum.toInt() xor data[i].toInt()).toByte()
    }
    return checksum
}
```

### Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø­Ø²Ù…Ø© ÙƒØ§Ù…Ù„Ø©
```
AA 55 46                              // Header + Length
00 00 03 E8                           // Timestamp: 1000ms
00 64 FF 9C 00 00                     // Roll:10Â°, Pitch:-10Â°, Yaw:0Â°
00 00 03 E8 26 AC                     // Accel: 0, 10, 98.04 (gravity)
03 F5 00 C8                           // Pressure: 1013hPa, Alt: 20m
...                                   // GPS + Servos + Tracking
25                                    // Checksum âœ“
```

---

## 3.4 Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø·ÙŠØ±Ø§Ù† (STM32 Flight - 10 Ø¨Ø§ÙŠØª)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª Ø§Ù„ÙÙ†ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø­Ø¬Ù… Ø§Ù„Ø­Ø²Ù…Ø©** | 10 Ø¨Ø§ÙŠØª |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„** | 50 Hz |
| **Ø§Ù„Ø§ØªØµØ§Ù„** | USB CDC Serial |
| **ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª** | Little Endian |

### Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø­Ø²Ù…Ø©
| Ø§Ù„Ø¨Ø§ÙŠØª | Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„Ù†ÙˆØ¹ | Ø§Ù„Ù†Ø·Ø§Ù‚ | Ø§Ù„ÙˆØµÙ |
|--------|-------|-------|--------|-------|
| 0 | Header 1 | byte | - | `0xAA` |
| 1 | Header 2 | byte | - | `0x08` |
| 2-3 | Throttle | uint16 | 0-1000 | Ù‚ÙˆØ© Ø§Ù„Ø¯ÙØ¹ |
| 4-5 | Roll | int16 | Â±500 | Ø§Ù„Ù…ÙŠÙ„Ø§Ù† ÙŠÙ…ÙŠÙ†/ÙŠØ³Ø§Ø± |
| 6-7 | Pitch | int16 | Â±500 | Ø§Ù„Ù…ÙŠÙ„Ø§Ù† Ø£Ù…Ø§Ù…/Ø®Ù„Ù |
| 8-9 | Yaw | int16 | Â±500 | Ø§Ù„Ø¯ÙˆØ±Ø§Ù† |

### Ø¢Ù„ÙŠØ© Ø§Ù„Ø§ÙƒØªØ´Ø§Ù (Handshake)
```
Android â†’ STM32: "ID?" (0x49 0x44 0x3F)
STM32 â†’ Android: "OK_STM32_REV1" (Ø®Ù„Ø§Ù„ 200ms)
```

### Ù…Ø«Ø§Ù„
```kotlin
// Ø·ÙŠØ±Ø§Ù† Ù„Ù„Ø£Ù…Ø§Ù… Ø¨Ù€ 50% Ù‚ÙˆØ©
val packet = byteArrayOf(
    0xAA.toByte(), 0x08,        // Header
    0xF4, 0x01,                 // Throttle: 500
    0x00, 0x00,                 // Roll: 0
    0xF4, 0x00,                 // Pitch: 244 (forward)
    0x00, 0x00                  // Yaw: 0
)
```

---

## 3.5 ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¹Ø±Ø¶ (HUD)

### Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¹Ø±Ø¶
| Ø§Ù„Ø¹Ù†ØµØ± | Ø§Ù„ÙˆØµÙ | Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ« |
|--------|-------|--------------|
| **Crosshair** | Ø´Ø¹ÙŠØ±Ø§Øª Ø§Ù„ØªØµÙˆÙŠØ¨ | 60 FPS |
| **Target Box** | Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù‡Ø¯Ù + Ù…Ø¹Ø±Ù Ø§Ù„ØªØªØ¨Ø¹ | 30 FPS |
| **Confidence Bar** | Ù†Ø³Ø¨Ø© Ø§Ù„Ø«Ù‚Ø© Ø¨Ø§Ù„Ù‡Ø¯Ù | 30 FPS |
| **Status Text** | ACQUIRING/TRACKING/ENGAGED | Ø­Ø³Ø¨ Ø§Ù„Ø­Ø¯Ø« |
| **Telemetry Overlay** | GPS/Battery/FPS | 1-10 Hz |
| **Threat Level** | Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯ (CRITICAL/HIGH/MEDIUM/LOW) | Ø­Ø³Ø¨ Ø§Ù„Ø­Ø¯Ø« |

### Ø¨Ù†ÙŠØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØªØ¨Ø¹
```kotlin
data class TrackingResult(
    val targetId: Int,           // Ù…Ø¹Ø±Ù Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙØ±ÙŠØ¯
    val boundingBox: RectF,      // Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù…Ø±Ø¨Ø¹
    val confidence: Float,       // 0.0 - 1.0
    val className: String,       // "tank", "vehicle", etc.
    val state: TrackState,       // ACQUIRING, TRACKING, ENGAGED
    val threatLevel: ThreatLevel // CRITICAL, HIGH, MEDIUM, LOW
)
```

---

## 3.6 ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Data Logging)

### Ù…Ù„ÙØ§Øª CSV - GPS
| Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„Ù†ÙˆØ¹ | Ø§Ù„ÙˆØµÙ |
|-------|-------|-------|
| timestamp | string | Ø§Ù„ÙˆÙ‚Øª Ø¨ØµÙŠØºØ© ISO 8601 |
| latitude | double | Ø®Ø· Ø§Ù„Ø¹Ø±Ø¶ |
| longitude | double | Ø®Ø· Ø§Ù„Ø·ÙˆÙ„ |
| altitude | double | Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ (Ù…ØªØ±) |
| speed | float | Ø§Ù„Ø³Ø±Ø¹Ø© (Ù…/Ø«) |
| bearing | float | Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ø¯Ø±Ø¬Ø©) |
| accuracy | float | Ø§Ù„Ø¯Ù‚Ø© (Ù…ØªØ±) |
| satellites | int | Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ù‚Ù…Ø§Ø± |
| hdop | float | HDOP |
| vdop | float | VDOP |
| fix_type | int | Ù†ÙˆØ¹ Ø§Ù„Ù€ Fix |
| source | string | "PHONE" Ø£Ùˆ "EXTERNAL" |

### Ù…Ø³Ø§Ø± Ø§Ù„Ø­ÙØ¸
```
/storage/emulated/0/Download/
â”œâ”€â”€ GPS_External_2026-01-12_163000.csv
â”œâ”€â”€ GPS_Phone_2026-01-12_163000.csv
â””â”€â”€ Mission_Recording_2026-01-12.mp4
```

---

# Ø§Ù„ÙØµÙ„ 4: Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„Ø§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©

## 4.1 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ CAN Bus (Waveshare USB-CAN-A)

### Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ù…Ø­ÙˆÙ„** | Waveshare USB-CAN-A |
| **VID** | `0x1A86` (CH340) |
| **Ø³Ø±Ø¹Ø© CAN** | 2 Mbps |
| **Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø®Ø·** | 120Î© Ø¹Ù„Ù‰ Ø·Ø±ÙÙŠ Ø§Ù„Ø¨Ø§Øµ |

### ØªØºÙ„ÙŠÙ Ø§Ù„Ø¥Ø·Ø§Ø± (Waveshare Binary)
```
[HEAD: 0xAA][TYPE][ID_LOW][ID_HIGH][DLC][DATA_0...7][CHECKSUM]
```

| Ø§Ù„Ø¨Ø§ÙŠØª | Ø§Ù„ÙˆØµÙ |
|--------|-------|
| HEAD | `0xAA` Ø«Ø§Ø¨Øª |
| TYPE | `0xC0` (Standard) Ø£Ùˆ `0xC1` (Extended) |
| ID | Ù…Ø¹Ø±Ù CAN (11-bit Ø£Ùˆ 29-bit) |
| DLC | Ø·ÙˆÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (0-8) |
| DATA | Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ø­ØªÙ‰ 8 Ø¨Ø§ÙŠØª) |
| CHECKSUM | Ù…Ø¬Ù…ÙˆØ¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª mod 256 |

### Ø£ÙˆØ§Ù…Ø± XQPOWER v022
```kotlin
object CANServoProtocol {
    const val CMD_SET_POSITION = 0x01
    const val CMD_SET_VELOCITY = 0x02
    const val CMD_READ_FEEDBACK = 0x05
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø²Ø§ÙˆÙŠØ©: -100Â° to +100Â° â†’ int16 Ã— 10
    fun angleToRaw(angle: Float): Short = (angle * 10).toInt().toShort()
}
```

---

## 4.2 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Serial Ø§Ù„Ù…ÙˆØ­Ø¯ (STM32 5-Byte)

### Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©
| Ø§Ù„Ø´Ø±ÙŠØ­Ø© | VID | PID |
|---------|-----|-----|
| CH340 | 0x1A86 | 0x7523 |
| FTDI | 0x0403 | 0x6001 |
| CP2102 | 0x10C4 | 0xEA60 |
| STM32 | 0x0483 | 0x5740 |
| Arduino | 0x2341 | Ù…ØªØ¹Ø¯Ø¯ |

### Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø­Ø²Ù…Ø©
```kotlin
object UnifiedProtocol {
    const val OPCODE_MOVE = 0x08
    const val OPCODE_READ = 0x00
    const val NEUTRAL_POSITION = 8191
    const val UNITS_PER_DEGREE = 40.0f
    
    fun buildMoveCommand(servoId: Int, angleDegrees: Float): ByteArray {
        val position = ((angleDegrees * UNITS_PER_DEGREE) + NEUTRAL_POSITION)
            .toInt().coerceIn(0, 16383)
        
        val syncId = (0x80 or OPCODE_MOVE or ((servoId shr 7) and 0x03)).toByte()
        val id = (servoId and 0x7F).toByte()
        val hpos = ((position shr 7) and 0x7F).toByte()
        val lpos = (position and 0x7F).toByte()
        val checksum = ((syncId.toInt() xor id.toInt() xor 
                         hpos.toInt() xor lpos.toInt()) and 0x7F).toByte()
        
        return byteArrayOf(syncId, id, hpos, lpos, checksum)
    }
    
    fun buildReadCommand(servoId: Int): ByteArray {
        val syncId = (0x80 or OPCODE_READ or ((servoId shr 7) and 0x03)).toByte()
        val id = (servoId and 0x7F).toByte()
        val checksum = ((syncId.toInt() xor id.toInt()) and 0x7F).toByte()
        
        return byteArrayOf(syncId, id, 0x00, 0x00, checksum)
    }
}
```

### ØªÙˆÙ‚ÙŠØª Round-Robin
```
Servo 1: [Command 5B] â†’ [Read Req 5B] â†’ [Wait 2ms] â†’ [Read 7B]
Servo 2: [Command 5B] â†’ [Read Req 5B] â†’ [Wait 2ms] â†’ [Read 7B]
Servo 3: [Command 5B] â†’ [Read Req 5B] â†’ [Wait 2ms] â†’ [Read 7B]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total Cycle: ~10ms (100Hz loop â†’ ~50Hz per-servo reporting)
```

---

## 4.3 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ù‚ÙŠØ§Ø³ (73-Byte Telemetry)

### Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø²Ù…Ø© Ø§Ù„Ù‚ÙŠØ§Ø³
```kotlin
class TelemetryStreamer {
    private val buffer = ByteBuffer.allocate(73)
        .order(ByteOrder.LITTLE_ENDIAN)
    
    fun buildPacket(
        orientation: FloatArray,     // Roll, Pitch, Yaw (degrees)
        acceleration: FloatArray,    // X, Y, Z (m/sÂ²)
        gps: GPSData,
        servoCmds: FloatArray,       // 4 servo targets
        servoFB: FloatArray,         // 4 servo feedbacks
        tracking: TrackingResult?,
        battery: BatteryInfo
    ): ByteArray {
        buffer.clear()
        
        // Header
        buffer.put(0xAA.toByte())
        buffer.put(0x55.toByte())
        buffer.put(70.toByte())
        
        // Timestamp
        buffer.putInt((System.currentTimeMillis() % Int.MAX_VALUE).toInt())
        
        // Orientation (degrees Ã— 10)
        buffer.putShort((orientation[0] * 10).toInt().toShort())
        buffer.putShort((orientation[1] * 10).toInt().toShort())
        buffer.putShort((orientation[2] * 10).toInt().toShort())
        
        // Acceleration (m/sÂ² Ã— 100)
        buffer.putShort((acceleration[0] * 100).toInt().toShort())
        buffer.putShort((acceleration[1] * 100).toInt().toShort())
        buffer.putShort((acceleration[2] * 100).toInt().toShort())
        
        // ... GPS, Servos, Tracking, Battery ...
        
        // Checksum
        val data = buffer.array()
        data[72] = calculateChecksum(data)
        
        return data
    }
}
```

---

## 4.4 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ KCA GPS

### Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© CRC-16 CCITT
```kotlin
fun crc16CCITT(data: ByteArray, offset: Int, length: Int): Int {
    var crc = 0
    for (i in offset until offset + length) {
        crc = crc xor (data[i].toInt() and 0xFF shl 8)
        for (j in 0 until 8) {
            crc = if (crc and 0x8000 != 0) {
                (crc shl 1) xor 0x1021
            } else {
                crc shl 1
            }
        }
    }
    return crc and 0xFFFF
}
```

### ØªØ­Ù„ÙŠÙ„ Ø­Ø²Ù…Ø© KCA
```kotlin
class KcaParser {
    fun parse(data: ByteArray): KcaNavData? {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡ÙŠØ¯Ø±
        if (data[0] != 0x81.toByte() || data[1] != 0x7E.toByte()) {
            return null
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† CRC
        val payload = data.sliceArray(2..161)
        val expectedCRC = ((data[162].toInt() and 0xFF) shl 8) or 
                          (data[163].toInt() and 0xFF)
        if (crc16CCITT(payload, 0, 160) != expectedCRC) {
            return null
        }
        
        // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        val buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN)
        return KcaNavData(
            state = buffer.get(1).toInt(),
            latitude = buffer.getFloat(72),
            longitude = buffer.getFloat(76),
            altitude = buffer.getFloat(80),
            // ...
        )
    }
}
```

---

# Ø§Ù„ÙØµÙ„ 5: Ù…Ø®Ø·Ø·Ø§Øª Ø§Ù„ØªØ¯ÙÙ‚

## 5.1 Ù…Ø®Ø·Ø· ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼              â–¼              â–¼              â–¼            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ğŸ“· Camera  â”‚â”‚  ğŸ§­ IMU      â”‚â”‚  ğŸ“ GPS      â”‚â”‚ âš™ï¸ Servo â”‚â”‚ ğŸ‘† User  â”‚
â”‚   CameraX    â”‚â”‚  Sensors     â”‚â”‚  Location    â”‚â”‚ Feedback â”‚â”‚ Touch    â”‚
â”‚   1080p 30Hz â”‚â”‚  100+ Hz     â”‚â”‚  1-10 Hz     â”‚â”‚ 50-100Hz â”‚â”‚ Events   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
       â”‚               â”‚               â”‚             â”‚           â”‚
       â–¼               â–¼               â–¼             â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ø·Ø¨Ù‚Ø© Ø¯Ù…Ø¬ Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª                             â”‚
â”‚            Camera 70% + IMU 20% + GPS 10%                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   FusedSensorData   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 5.2 Ù…Ø®Ø·Ø· ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©                                   â”‚
â”‚              (Detection â†’ Tracking â†’ Decision)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                       â”‚                       â”‚
       â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âš™ï¸ Servos   â”‚       â”‚  ğŸ“¡ Telemetryâ”‚       â”‚  ğŸ–¥ï¸ HUD     â”‚
â”‚  CAN/Serial  â”‚       â”‚  73-byte     â”‚       â”‚  Display    â”‚
â”‚  50 Hz       â”‚       â”‚  60 Hz       â”‚       â”‚  30-60 FPS  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                      â”‚                      â”‚
       â–¼                      â–¼                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Gimbal/Motor â”‚       â”‚ Python GCS   â”‚       â”‚ Operator     â”‚
â”‚ (Physical)   â”‚       â”‚ Viewer       â”‚       â”‚ Interface    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 5.3 Ù…Ø®Ø·Ø· Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„ÙƒÙ„ÙŠ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          SAQR SEEKER SYSTEM                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  ğŸ“· Camera      â”‚                              â”‚  âš™ï¸ Servos      â”‚
  â”‚  (1080p 30Hz)   â”‚â”€â”€â”                       â”Œâ”€â”€â–¶â”‚  (CAN/Serial)   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                       â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚                       â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  ğŸ§­ IMU         â”‚â”€â”€â”¼â”€â”€â–¶â”‚               â”‚â”€â”€â”€â”¼â”€â”€â–¶â”‚  ğŸ“¡ Telemetry   â”‚
  â”‚  (100+ Hz)      â”‚  â”‚   â”‚   ANDROID     â”‚   â”‚   â”‚  (73-byte 60Hz) â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚    BRAIN      â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚   â”‚               â”‚   â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚  â€¢ YOLOv8     â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  ğŸ“ GPS         â”‚â”€â”€â”¼â”€â”€â–¶â”‚  â€¢ ByteTrack  â”‚â”€â”€â”€â”¼â”€â”€â–¶â”‚  ğŸ–¥ï¸ HUD        â”‚
  â”‚  (Int+External) â”‚  â”‚   â”‚  â€¢ Kalman     â”‚   â”‚   â”‚  (30-60 FPS)    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚  â€¢ PID        â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚   â”‚  â€¢ Decision   â”‚   â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  ğŸ‘† User Input  â”‚â”€â”€â”˜           â”‚           â””â”€â”€â–¶â”‚  ğŸ“¹ Recording   â”‚
  â”‚  (Touch)        â”‚              â”‚               â”‚  (MP4 + CSV)    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚  âœˆï¸ STM32     â”‚
                          â”‚  Flight Ctrl  â”‚
                          â”‚  (10-byte)    â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# Ø§Ù„Ù…Ù„Ø§Ø­Ù‚

## Ù…Ù„Ø­Ù‚ Ø£: Ø¬Ø¯ÙˆÙ„ Ù…Ø¹Ø±ÙØ§Øª USB Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©

| Ø§Ù„Ø¬Ù‡Ø§Ø² | VID | PID | Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… |
|--------|-----|-----|-----------|
| **Waveshare CAN** | 0x1A86 | 0x7523 | CAN Bus Ù„Ù„Ø³ÙŠØ±ÙÙˆÙ‡Ø§Øª |
| **FTDI** | 0x0403 | 0x6001 | Telemetry Radio |
| **CP2102** | 0x10C4 | 0xEA60 | Serial Servos |
| **STM32 VCP** | 0x0483 | 0x5740 | Flight Controller |
| **CH340** | 0x1A86 | 0x7523 | Multi-purpose |

## Ù…Ù„Ø­Ù‚ Ø¨: Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Serial Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠØ©

| Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… | Baud Rate | Data Bits | Stop Bits | Parity |
|-----------|-----------|-----------|-----------|--------|
| Servos | 115200 | 8 | 1 | None |
| Telemetry | 115200 | 8 | 1 | None |
| CAN Adapter | 2000000 | 8 | 1 | None |
| KCA GPS | 115200 | 8 | 1 | None |

## Ù…Ù„Ø­Ù‚ Ø¬: Ø±Ù…ÙˆØ² Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

| Ø§Ù„Ø±Ù…Ø² | Ø§Ù„ÙˆØµÙ | Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ |
|-------|-------|---------|
| `E001` | ÙØ´Ù„ Ø§ØªØµØ§Ù„ USB | ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒØ§Ø¨Ù„ ÙˆØ§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª |
| `E002` | ÙØ´Ù„ CRC | Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø³Ù„Ø§Ùƒ |
| `E003` | Servo Timeout | ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙˆØµÙŠÙ„ ÙˆØ§Ù„Ø·Ø§Ù‚Ø© |
| `E004` | GPS No Fix | Ø§Ù†ØªØ¸Ø± Ø£Ùˆ Ø§Ù†ØªÙ‚Ù„ Ù„Ù…ÙƒØ§Ù† Ù…ÙØªÙˆØ­ |
| `E005` | Camera Error | Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ |

## Ù…Ù„Ø­Ù‚ Ø¯: Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©

### Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰
- **Ø§Ù„Ù‡Ø§ØªÙ**: Android 9.0+ØŒ USB OTG
- **Ø§Ù„Ù…Ø­ÙˆÙ„**: Waveshare USB-CAN-A
- **Ø§Ù„Ø·Ø§Ù‚Ø©**: 5V/2A Ø®Ø§Ø±Ø¬ÙŠ Ù„Ù„Ø³ÙŠØ±ÙÙˆÙ‡Ø§Øª

### Ø§Ù„Ù…ÙˆØµÙ‰ Ø¨Ù‡
- **Ø§Ù„Ù‡Ø§ØªÙ**: Samsung S23 Ultra Ø£Ùˆ Ù…Ø§ ÙŠØ¹Ø§Ø¯Ù„Ù‡
- **Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬**: Snapdragon 8 Gen 2+
- **Ø§Ù„Ø°Ø§ÙƒØ±Ø©**: 8GB+ RAM

---

# Ø§Ù„ÙØµÙ„ 6: Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©

## 6.1 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Gimbal Seeker (Ø§Ù„ØªØ­ÙƒÙ…)

### Ø­Ø²Ù…Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù…Ù† Ù…Ø±ÙƒØ² Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª (OC â†’ Seeker)
**Ø­Ø¬Ù… Ø§Ù„Ø­Ø²Ù…Ø©**: 20 Ø¨Ø§ÙŠØª | **Header**: `0x55AA`

| Ø§Ù„Ø¨Ø§ÙŠØª | Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„Ø­Ø¬Ù… | Ø§Ù„Ù†ÙˆØ¹ | Ø§Ù„ÙˆØµÙ |
|--------|-------|-------|-------|-------|
| 0-1 | Header | 2B | uint16 | `0x55AA` |
| 2 | Stabilization | 1B | uint8 | 0: OFF, 1: ON |
| 3 | Mode | 1B | uint8 | 0: None, 1: Position, 2: Rate, 3: Test, 4: Zero |
| 4-5 | Yaw | 2B | int16 | Ø¯Ø±Ø¬Ø© Ã— 100 Ø£Ùˆ Ø¯Ø±Ø¬Ø©/Ø« Ã— 100 |
| 6-7 | Pitch | 2B | int16 | Ø¯Ø±Ø¬Ø© Ã— 100 Ø£Ùˆ Ø¯Ø±Ø¬Ø©/Ø« Ã— 100 |
| 8 | Control | 1B | bitflags | bit5: Link, bit4: Fire, bits1-0: Mode |
| 9-10 | Time | 2B | uint16 | ms Ã— 100 |
| 11 | Target | 1B | bitflags | bit7: Size, bits5-4: Type |
| 12-17 | Reserved | 6B | - | Ø­Ø´Ùˆ |
| 18-19 | CRC16 | 2B | uint16 | Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø²Ù…Ø© |

### Control Byte ØªÙØµÙŠÙ„Ø§Ù‹
```
bit 5: Link Status (1 = Connected)
bit 4: Fire Command (1 = Fire)
bits 1-0: Search Mode
  00 = None
  01 = Stop
  10 = Search
  11 = Reserved
```

### Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø­Ø²Ù…Ø© Ø§Ù„ØªØ­ÙƒÙ…
```kotlin
fun buildGimbalControlPacket(
    stabilization: Boolean,
    mode: Int,
    yaw: Float,
    pitch: Float,
    fire: Boolean
): ByteArray {
    val buffer = ByteBuffer.allocate(20).order(ByteOrder.LITTLE_ENDIAN)
    
    buffer.putShort(0x55AA.toShort())           // Header
    buffer.put(if (stabilization) 1 else 0)    // Stab
    buffer.put(mode.toByte())                   // Mode
    buffer.putShort((yaw * 100).toInt().toShort())    // Yaw
    buffer.putShort((pitch * 100).toInt().toShort())  // Pitch
    
    var control = 0x20  // Link = 1
    if (fire) control = control or 0x10
    buffer.put(control.toByte())
    
    // ... Time, Target, Reserved ...
    
    val data = buffer.array()
    val crc = calculateCRC16(data, 0, 18)
    buffer.putShort(18, crc.toShort())
    
    return data
}
```

---

## 6.2 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Gimbal Seeker (Ø§Ù„Ø­Ø§Ù„Ø©)

### Ø­Ø²Ù…Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø¬ÙŠÙ…Ø¨Ø§Ù„ (Seeker â†’ OC)
**Ø­Ø¬Ù… Ø§Ù„Ø­Ø²Ù…Ø©**: 35 Ø¨Ø§ÙŠØª | **Header**: `0xAACC`

| Ø§Ù„Ø¨Ø§ÙŠØª | Ø§Ù„Ø­Ù‚Ù„ | Ø§Ù„Ø­Ø¬Ù… | Ø§Ù„Ù†ÙˆØ¹ | Ø§Ù„ÙˆØµÙ |
|--------|-------|-------|-------|-------|
| 0-1 | Header | 2B | uint16 | `0xAACC` |
| 2-5 | Yaw/Pitch | 4B | int16[2] | Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ (Ø¯Ø±Ø¬Ø© Ã— 100) |
| 6-9 | Rates | 4B | int16[2] | Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø¯Ø±Ø¬Ø©/Ø« Ã— 100) |
| 10-13 | Image X/Y | 4B | int16[2] | Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù‡Ø¯Ù ÙÙŠ Ø§Ù„ØµÙˆØ±Ø© |
| 14-16 | Temps | 3B | uint8[3] | Ø­Ø±Ø§Ø±Ø©: Yaw Gyro, Pitch Gyro, GPU |
| 17 | Pressure | 1B | uint8 | Ø§Ù„Ø¶ØºØ· Ø§Ù„Ø¬ÙˆÙŠ |
| 18 | State | 1B | bitflags | bits7-4: Mode, bits3-2: Result, bits1-0: Work |
| 19 | Errors | 1B | uint8 | Ø£ÙƒÙˆØ§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ |
| 20 | IPU | 1B | bitflags | bit6: Lock, bits5-4: Find, bits2-0: IPU State |
| 21-22 | Dimensions | 2B | uint8[2] | Ø¹Ø±Ø¶/Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ù‡Ø¯Ù Ã· 10 |
| 23 | Fire | 1B | uint8 | 0: Off, 1: On |
| 24-32 | Reserved | 9B | - | Ø­Ø´Ùˆ |
| 33-34 | CRC16 | 2B | uint16 | Ø§Ù„ØªØ­Ù‚Ù‚ |

### State Byte ØªÙØµÙŠÙ„Ø§Ù‹
```
bits 7-4: Operating Mode
  0000 = Idle
  0001 = Searching
  0010 = Tracking
  0011 = Locked
  
bits 3-2: Result
  00 = None
  01 = Success
  10 = Failed
  
bits 1-0: Work State
  00 = Standby
  01 = Active
  10 = Error
```

### Error Codes
| Ø§Ù„Ø±Ù…Ø² | Ø§Ù„ÙˆØµÙ |
|-------|-------|
| 1 | IPU Error - Ø®Ø·Ø£ ÙÙŠ ÙˆØ­Ø¯Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© |
| 2 | Gyro Offset - Ø§Ù†Ø­Ø±Ø§Ù Ø§Ù„Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨ |
| 3 | Gyro Error - Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¬ÙŠØ±ÙˆØ³ÙƒÙˆØ¨ |
| 4 | Angle Error - Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© |
| 5 | Drift - Ø§Ù†Ø¬Ø±Ø§Ù |

### ØªØ­Ù„ÙŠÙ„ Ø­Ø²Ù…Ø© Ø§Ù„Ø­Ø§Ù„Ø©
```kotlin
data class GimbalStatus(
    val yaw: Float,
    val pitch: Float,
    val yawRate: Float,
    val pitchRate: Float,
    val targetX: Int,
    val targetY: Int,
    val isLocked: Boolean,
    val mode: Int,
    val error: Int
)

fun parseGimbalStatus(data: ByteArray): GimbalStatus? {
    if (data.size < 35) return null
    
    val buffer = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN)
    
    // Check header
    if (buffer.getShort(0) != 0xAACC.toShort()) return null
    
    // Verify CRC
    val expectedCRC = buffer.getShort(33).toInt() and 0xFFFF
    if (calculateCRC16(data, 0, 33) != expectedCRC) return null
    
    return GimbalStatus(
        yaw = buffer.getShort(2) / 100f,
        pitch = buffer.getShort(4) / 100f,
        yawRate = buffer.getShort(6) / 100f,
        pitchRate = buffer.getShort(8) / 100f,
        targetX = buffer.getShort(10).toInt(),
        targetY = buffer.getShort(12).toInt(),
        isLocked = (data[20].toInt() and 0x40) != 0,
        mode = (data[18].toInt() shr 4) and 0x0F,
        error = data[19].toInt()
    )
}
```

---

## 6.3 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Micro XRCE-DDS (Ù„Ù„Ù€ PX4)

### Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©
Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ø¹ Ù…ØªØ­ÙƒÙ…Ø§Øª Ø§Ù„Ø·ÙŠØ±Ø§Ù† PX4 (Ù…Ø«Ù„ CUAV X7Pro) Ø¹Ø¨Ø± Serial-UART.

### Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø§Ù„Ø§ØªØµØ§Ù„** | UART Serial |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙˆØ¯** | 921600 bps |
| **Ø§Ù„ØªØ£Ø·ÙŠØ±** | HDLC-like |
| **Flag Byte** | `0x7E` |

### Ø¨Ù†ÙŠØ© Ø§Ù„Ø¥Ø·Ø§Ø±
```
[FLAG: 0x7E][PAYLOAD with Byte Stuffing][CRC-16 CCITT][FLAG: 0x7E]
```

### Byte Stuffing
```kotlin
fun stuffBytes(data: ByteArray): ByteArray {
    val result = mutableListOf<Byte>()
    for (b in data) {
        when (b) {
            0x7E.toByte() -> {
                result.add(0x7D)
                result.add(0x5E)  // 0x7E XOR 0x20
            }
            0x7D.toByte() -> {
                result.add(0x7D)
                result.add(0x5D)  // 0x7D XOR 0x20
            }
            else -> result.add(b)
        }
    }
    return result.toByteArray()
}
```

### Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙØ±Ø¹ÙŠØ©
| Ø§Ù„Ù†ÙˆØ¹ | Ø§Ù„ÙˆØµÙ | Ø§Ù„ØªÙƒØ±Ø§Ø± |
|-------|-------|---------|
| `TIMESTAMP` | Ø·Ù„Ø¨ Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙˆÙ‚Øª | 1 Hz |
| `TIMESTAMP_REPLY` | Ø±Ø¯ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© | 1 Hz |
| `HEARTBEAT` | Ù†Ø¨Ø¶ Ø§Ù„Ø­ÙŠØ§Ø© | 1 Hz |
| `ACKNACK` | ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù… | Ø­Ø³Ø¨ Ø§Ù„Ø·Ù„Ø¨ |
| `DATA` | Ø¨ÙŠØ§Ù†Ø§Øª IMU/Attitude | 50-200 Hz |

### Topics Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©
```kotlin
enum class PX4Topic(val id: Int) {
    VEHICLE_ATTITUDE(0x01),
    VEHICLE_LOCAL_POSITION(0x02),
    VEHICLE_GLOBAL_POSITION(0x03),
    SENSOR_COMBINED(0x04),
    BATTERY_STATUS(0x05),
    VEHICLE_STATUS(0x06)
}
```

---

## 6.4 Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ LAMP Control (ASCII)

### Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©
Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ ØªØ­ÙƒÙ… Ø¨Ø³ÙŠØ· Ù„Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ø«Ø§Ù†ÙˆÙŠØ© Ø¹Ù„Ù‰ Ù…ØªØ­ÙƒÙ…Ø§Øª STM32.

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø­Ø¬Ù… Ø§Ù„Ø£Ù…Ø±** | 2-3 Ø¨Ø§ÙŠØª (ASCII) |
| **Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨ÙˆØ¯** | 115200 bps |
| **Ø§Ù„Ø§ØªØµØ§Ù„** | USB Serial |

### Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø±
| Ø§Ù„Ø£Ù…Ø± | Ø§Ù„ÙˆØ¸ÙŠÙØ© | Ø§Ù„ÙˆØµÙ |
|-------|---------|-------|
| `ID?` | Ø§Ù„Ø§ÙƒØªØ´Ø§Ù | ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ±Ø¯ Ø§Ù„Ø¬Ù‡Ø§Ø² Ø¨Ù€ `STM32` |
| `L1` | ØªÙØ¹ÙŠÙ„ Ø¬Ù‡Ø§Ø² 1 | Ù†Ø¨Ø¶Ø© Ø²Ù…Ù†ÙŠØ© Ù„Ù„Ø¬Ù‡Ø§Ø² Ø§Ù„Ø£ÙˆÙ„ |
| `L2` | ØªÙØ¹ÙŠÙ„ Ø¬Ù‡Ø§Ø² 2 | Ù†Ø¨Ø¶Ø© Ø²Ù…Ù†ÙŠØ© Ù„Ù„Ø¬Ù‡Ø§Ø² Ø§Ù„Ø«Ø§Ù†ÙŠ |
| `OF` | Ø¥ÙŠÙ‚Ø§Ù Ø·ÙˆØ§Ø±Ø¦ | Ø¥ÙŠÙ‚Ø§Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© |

### ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø§ÙƒØªØ´Ø§Ù
```kotlin
suspend fun discoverSTM32Device(port: UsbSerialPort): Boolean {
    // Send discovery query
    port.write("ID?".toByteArray(), 100)
    
    // Wait for response
    delay(200)
    
    val buffer = ByteArray(64)
    val bytesRead = port.read(buffer, 200)
    
    if (bytesRead > 0) {
        val response = String(buffer, 0, bytesRead)
        return response.contains("STM32")
    }
    return false
}
```

### Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­ÙƒÙ…
```kotlin
class LampController(private val port: UsbSerialPort) {
    
    fun activateLamp1() {
        port.write("L1".toByteArray(), 50)
    }
    
    fun activateLamp2() {
        port.write("L2".toByteArray(), 50)
    }
    
    fun emergencyOff() {
        port.write("OF".toByteArray(), 50)
    }
}
```

---

# Ø§Ù„ÙØµÙ„ 7: Ø¥Ø¯Ø§Ø±Ø© USB Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©

## 7.1 Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© ÙˆØ§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©

### ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø§ÙƒØªØ´Ø§Ù
ÙŠØªØ¨Ø¹ Ø§Ù„Ù†Ø¸Ø§Ù… ØªØ³Ù„Ø³Ù„Ø§Ù‹ Ù…Ø­Ø¯Ø¯Ø§Ù‹ Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© ÙˆÙ…Ù†Ø¹ ØªØ¹Ø§Ø±Ø¶ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯:

```kotlin
class DeviceDiscoveryManager {
    
    suspend fun autoConnect() {
        // Priority 1: STM32 Bridge (Flight Controller)
        val stm32 = discoverSTM32()
        
        // Priority 2: Servo Actuators (CAN/Serial)
        val servos = discoverServos(exclude = listOf(stm32?.deviceName))
        
        // Priority 3: Telemetry Radio
        val telemetry = discoverTelemetry(
            exclude = listOf(stm32?.deviceName) + servos.map { it.deviceName }
        )
    }
}
```

### Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª
| Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© | Ø§Ù„Ø¬Ù‡Ø§Ø² | Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªØ¹Ø±ÙŠÙ |
|----------|--------|---------------|
| 1 | STM32 Flight Controller | ASCII "ID?" Handshake |
| 2 | CAN Bus (Waveshare) | VID: 0x1A86 + Baud: 2Mbps |
| 3 | Serial Servos | VID: 0x10C4 (CP2102) |
| 4 | Telemetry Radio | VID: 0x0403 (FTDI) |

## 7.2 ØªÙˆØ¨ÙˆÙ„ÙˆØ¬ÙŠØ§ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©

### Unified Virtual Bus (UVB) - Ø§Ù„Ù†Ø§Ù‚Ù„ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø§Ù„Ù…ÙˆØ­Ø¯
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Android    â”‚
â”‚   Brain     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ USB Hub
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â–¼          â–¼          â–¼          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”
   â”‚Port 0â”‚   â”‚Port 1â”‚   â”‚Port 2â”‚   â”‚Port 3â”‚
   â”‚ TX/RXâ”‚   â”‚ TX/RXâ”‚   â”‚ TX/RXâ”‚   â”‚ TX/RXâ”‚
   â””â”€â”€â”€â”¬â”€â”€â”˜   â””â”€â”€â”€â”¬â”€â”€â”˜   â””â”€â”€â”€â”¬â”€â”€â”˜   â””â”€â”€â”€â”¬â”€â”€â”˜
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                Shared Bus (Parallel TX)
                      â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â–¼          â–¼       â–¼          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”
   â”‚Servo1â”‚   â”‚Servo2â”‚ â”‚Servo3â”‚   â”‚Servo4â”‚
   â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜
```

### Asymmetric Hybrid Topology (Ø§Ù„Ù…Ø¹ÙŠØ§Ø± Ø§Ù„Ø°Ù‡Ø¨ÙŠ)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Android    â”‚
â”‚   Brain     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ USB Hub (4-Port)
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                                       â”‚
   â–¼                                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Port 0â”‚ â”€â”€â”€â”€ TX Only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  All Servos  â”‚
â”‚Masterâ”‚                           â”‚   (RX pins)  â”‚
â””â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼         â–¼           â–¼           â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”
               â”‚Servo1â”‚  â”‚Servo2â”‚    â”‚Servo3â”‚    â”‚Servo4â”‚
               â”‚  TX  â”‚  â”‚  TX  â”‚    â”‚  TX  â”‚    â”‚  TX  â”‚
               â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜    â””â”€â”€â”€â”¬â”€â”€â”˜    â””â”€â”€â”€â”¬â”€â”€â”˜
                   â”‚         â”‚           â”‚           â”‚
                   â–¼         â–¼           â–¼           â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”
               â”‚Port 1â”‚  â”‚Port 2â”‚    â”‚Port 3â”‚    â”‚Port 4â”‚
               â”‚RX Onlyâ”‚ â”‚RX Onlyâ”‚   â”‚RX Onlyâ”‚   â”‚RX Onlyâ”‚
               â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜
```

**Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:**
- **Ø¹Ù…Ù„ÙŠØ© ÙƒØªØ§Ø¨Ø© ÙˆØ§Ø­Ø¯Ø©** Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø³ÙŠØ±ÙÙˆÙ‡Ø§Øª
- **Ù„Ø§ ØªØµØ§Ø¯Ù…** ÙÙŠ Ø§Ù„ÙÙŠØ¯Ø¨Ø§Ùƒ
- **50Hz+ ØªØ­Ø¯ÙŠØ«** Ù„ÙƒÙ„ Ø³ÙŠØ±ÙÙˆ

---

## 7.3 ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø²Ù… (Packet Batching)

### Super-Frame (20 Ø¨Ø§ÙŠØª)
Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ØŒ ÙŠØªÙ… ØªØ¬Ù…ÙŠØ¹ 4 Ø£ÙˆØ§Ù…Ø± 5-Ø¨Ø§ÙŠØª ÙÙŠ Ø¥Ø·Ø§Ø± ÙˆØ§Ø­Ø¯:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Broadcast Super-Frame (20 Bytes)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Frame_S1     â”‚   Frame_S2     â”‚   Frame_S3     â”‚   Frame_S4      â”‚
â”‚   (5 bytes)    â”‚   (5 bytes)    â”‚   (5 bytes)    â”‚   (5 bytes)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ø§Ù„ÙƒÙˆØ¯
```kotlin
fun buildSuperFrame(
    s1Angle: Float,
    s2Angle: Float,
    s3Angle: Float,
    s4Angle: Float
): ByteArray {
    val frame1 = UnifiedProtocol.buildMoveCommand(1, s1Angle)
    val frame2 = UnifiedProtocol.buildMoveCommand(2, s2Angle)
    val frame3 = UnifiedProtocol.buildMoveCommand(3, s3Angle)
    val frame4 = UnifiedProtocol.buildMoveCommand(4, s4Angle)
    
    return frame1 + frame2 + frame3 + frame4  // 20 bytes total
}
```

### ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
```
Baud Rate: 115200 bps
20 bytes Ã— 10 bits = 200 bits
Time = 200 / 115200 â‰ˆ 1.7ms per port

4 ports sequential = 6.8ms
Control frequency = ~150Hz (theoretical)
Practical frequency = 100Hz (with processing)
```

---

## 7.4 ØªØ¬Ù†Ø¨ Ø§Ù„ØªØµØ§Ø¯Ù… (Collision Mitigation)

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©
```
Tâ‚€: Master sends broadcast command
Tâ‚€ + 1ms: Servo1 starts responding
Tâ‚€ + 1ms: Servo2 starts responding  â† COLLISION!
Result: Bit corruption on shared RX line
```

### Ø§Ù„Ø­Ù„: Round-Robin Polling
```kotlin
class RoundRobinPoller(
    private val port: UsbSerialPort,
    private val servoIds: List<Int>
) {
    private val GUARD_INTERVAL_MS = 2L
    
    suspend fun pollCycle(commands: Map<Int, Float>) {
        for (id in servoIds) {
            val angle = commands[id] ?: continue
            
            // 1. Send position command
            val moveCmd = UnifiedProtocol.buildMoveCommand(id, angle)
            port.write(moveCmd, 20)
            
            // 2. Send feedback request
            val readCmd = UnifiedProtocol.buildReadCommand(id)
            port.write(readCmd, 20)
            
            // 3. Wait for servo to respond alone
            delay(GUARD_INTERVAL_MS)
            
            // 4. Read feedback (7 bytes expected)
            val buffer = ByteArray(16)
            val bytesRead = port.read(buffer, 15)
            
            if (bytesRead >= 7) {
                processFeedback(id, buffer)
            }
        }
    }
}
```

### Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«
```
Ù„Ù€ 3 Ø³ÙŠØ±ÙÙˆÙ‡Ø§Øª Ø¹Ù„Ù‰ Ø¨Ø§Øµ Ù…Ø´ØªØ±Ùƒ:

Per Servo:
  - Write Command: 5B Ã— 87Âµs/byte = 0.43ms
  - Write Read Request: 5B Ã— 87Âµs/byte = 0.43ms
  - Guard Interval: 2ms
  - Read Feedback: 7B Ã— 87Âµs/byte = 0.61ms
  - Total: ~3.5ms

Full Cycle: 3 Ã— 3.5ms = 10.5ms
Update Rate: ~95Hz loop, ~32Hz per servo
```

---

## 7.5 DTR/RTS Hardware Handshaking

### Ø£Ù‡Ù…ÙŠØ© DTR/RTS
Ø¨Ø¹Ø¶ Ù…Ø­ÙˆÙ„Ø§Øª USB-Serial (Ù…Ø«Ù„ CP2102) ØªØªØ·Ù„Ø¨ ØªÙØ¹ÙŠÙ„ Ø¥Ø´Ø§Ø±Ø§Øª DTR/RTS Ù„ØªÙ†Ø´ÙŠØ· Ø§Ù„Ù…Ø±Ø³Ù„/Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ.

```kotlin
fun configureSerialPort(port: UsbSerialPort) {
    port.open(connection)
    port.setParameters(
        115200,                    // Baud rate
        UsbSerialPort.DATABITS_8,  // Data bits
        UsbSerialPort.STOPBITS_1,  // Stop bits
        UsbSerialPort.PARITY_NONE  // Parity
    )
    
    // CRITICAL: Enable hardware flow control
    port.dtr = true
    port.rts = true
}
```

### Ø£Ø¹Ø±Ø§Ø¶ Ø¹Ø¯Ù… ØªÙØ¹ÙŠÙ„ DTR/RTS
| Ø§Ù„Ø¹Ø±Ø¶ | Ø§Ù„Ø³Ø¨Ø¨ |
|-------|-------|
| Ø§Ù„ÙƒØªØ§Ø¨Ø© "ØªÙ†Ø¬Ø­" Ù„ÙƒÙ† Ù„Ø§ Ø­Ø±ÙƒØ© | TX ØºÙŠØ± Ù†Ø´Ø· ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ§Ù‹ |
| Ù„Ø§ ÙÙŠØ¯Ø¨Ø§Ùƒ ÙŠÙØ³ØªÙ„Ù… | RX ØºÙŠØ± Ù†Ø´Ø· ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ§Ù‹ |
| LED Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ÙˆÙ„ Ù„Ø§ ÙŠÙˆÙ…Ø¶ | Ø§Ù„Ù…Ø­ÙˆÙ„ ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø³ÙƒÙˆÙ† |

---

# Ø§Ù„ÙØµÙ„ 8: Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ø¯Ù…Ø¬ Ø§Ù„Ø¹Ø³ÙƒØ±ÙŠØ©

## 8.1 Ø·Ø¨Ù‚Ø© Ø¯Ù…Ø¬ Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª (Sensor Fusion Layer)

### Ø§Ù„Ø£ÙˆØ²Ø§Ù†
| Ø§Ù„Ù…ØµØ¯Ø± | Ø§Ù„ÙˆØ²Ù† | Ø§Ù„Ø´Ø±Ø· |
|--------|-------|-------|
| Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ | 70% | Ø¥Ø¶Ø§Ø¡Ø© ÙƒØ§ÙÙŠØ©ØŒ Ù„Ø§ Ø¶Ø¨Ø§Ø¨ÙŠØ© |
| IMU | 20% | Ù…Ø³ØªÙˆÙ‰ Ø§Ù‡ØªØ²Ø§Ø² Ù…Ù†Ø®ÙØ¶ |
| GPS | 10% | Ø¯Ù‚Ø© < 10 Ù…ØªØ± |

### Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ø¨ÙŠØ¦ÙŠØ©
```kotlin
data class EnvironmentConfidence(
    val brightness: Float,      // 0-1
    val shakeLevel: Float,      // 0-1 (0 = stable)
    val gpsAccuracy: Float      // meters
)

fun calculateEnvironmentScore(env: EnvironmentConfidence): Float {
    val brightnessScore = env.brightness.coerceIn(0.2f, 0.8f) / 0.8f
    val stabilityScore = 1f - env.shakeLevel.coerceIn(0f, 0.5f) * 2
    val gpsScore = (1f - (env.gpsAccuracy / 20f)).coerceIn(0f, 1f)
    
    return (brightnessScore * 0.4f) + (stabilityScore * 0.4f) + (gpsScore * 0.2f)
}
```

---

## 8.2 Ø·Ø¨Ù‚Ø© Ø¯Ù…Ø¬ Ø§Ù„ØªØªØ¨Ø¹ (Track Fusion Layer)

### Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ù…ØµØ§Ø¯Ø±
| Ø§Ù„Ù…ØµØ¯Ø± | Ø§Ù„ÙˆØ²Ù† | Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… |
|--------|-------|-----------|
| YOLO High Confidence (>0.5) | 1.0 | ØªØ£ÙƒÙŠØ¯ Ø£Ø³Ø§Ø³ÙŠ |
| YOLO Low Confidence (<0.5) | 0.6 | Ø¯Ø¹Ù… Ø«Ø§Ù†ÙˆÙŠ |
| WhiteRectangle | 0.8 | Ø£Ù‡Ø¯Ø§Ù Ø¹Ø§Ù„ÙŠØ© Ø§Ù„ØªØ¨Ø§ÙŠÙ† |
| Motion History | 0.4 | ØªØªØ¨Ø¹ Ù…Ø³ØªÙ…Ø± |

### Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª (Weighted Box Fusion)
```kotlin
fun fuseDetections(
    yoloBoxes: List<Detection>,
    geometricBoxes: List<Detection>,
    motionBoxes: List<Detection>
): List<FusedTrack> {
    val allDetections = mutableListOf<WeightedDetection>()
    
    yoloBoxes.forEach { 
        val weight = if (it.confidence > 0.5f) 1.0f else 0.6f
        allDetections.add(WeightedDetection(it, weight))
    }
    
    geometricBoxes.forEach {
        allDetections.add(WeightedDetection(it, 0.8f))
    }
    
    motionBoxes.forEach {
        allDetections.add(WeightedDetection(it, 0.4f))
    }
    
    // IoU-based clustering and weighted averaging
    return clusterAndFuse(allDetections)
}
```

---

## 8.3 Ø·Ø¨Ù‚Ø© Ø¯Ù…Ø¬ Ø§Ù„Ù‚Ø±Ø§Ø± (Decision Fusion Layer)

### Ø­Ø³Ø§Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯
```kotlin
enum class ThreatLevel { CRITICAL, HIGH, MEDIUM, LOW }

fun calculateThreatLevel(
    targetClass: String,
    distance: Float,
    confidence: Float,
    behavior: TargetBehavior
): ThreatLevel {
    // Class weight (40%)
    val classScore = when (targetClass) {
        "turret" -> 1.0f
        "tank" -> 0.9f
        "armored_vehicle" -> 0.8f
        "person" -> 0.5f
        "car" -> 0.3f
        else -> 0.2f
    }
    
    // Distance weight (25%) - closer = higher threat
    val distanceScore = (1f - (distance / 1000f)).coerceIn(0f, 1f)
    
    // Confidence weight (25%)
    val confScore = confidence
    
    // Behavior weight (10%)
    val behaviorScore = when (behavior) {
        TargetBehavior.APPROACHING -> 1.0f
        TargetBehavior.STATIONARY -> 0.5f
        TargetBehavior.RETREATING -> 0.2f
    }
    
    val totalScore = (classScore * 0.4f) + (distanceScore * 0.25f) +
                     (confScore * 0.25f) + (behaviorScore * 0.1f)
    
    return when {
        totalScore > 0.85f -> ThreatLevel.CRITICAL
        totalScore > 0.65f -> ThreatLevel.HIGH
        totalScore > 0.40f -> ThreatLevel.MEDIUM
        else -> ThreatLevel.LOW
    }
}
```

### ØªØ³Ù„Ø³Ù„ Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
```
1. turret (Ø¨Ø±Ø¬ Ø¯Ø¨Ø§Ø¨Ø©)     â†’ Priority 0
2. tank (Ø¯Ø¨Ø§Ø¨Ø©)           â†’ Priority 1
3. armored_vehicle        â†’ Priority 2
4. person (Ø´Ø®Øµ)           â†’ Priority 3
5. car (Ø³ÙŠØ§Ø±Ø©)            â†’ Priority 4
```

---

## 8.4 Ø³Ù„Ø·Ø© Ø§Ù„Ù‚Ø±Ø§Ø± (Decision Authority)

### Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ¨Ø§Ùƒ (ROE)
```kotlin
data class ROEConfig(
    val authorizedClasses: Set<String>,
    val minConfidence: Float,
    val maxDistance: Float,
    val minDistance: Float,
    val noFireZones: List<GeoZone>,
    val timeoutSeconds: Int
)

class DecisionAuthority(private val roe: ROEConfig) {
    
    fun validateEngagement(target: TrackedTarget): EngagementDecision {
        // Check 1: Class Authorization
        if (target.className !in roe.authorizedClasses) {
            return EngagementDecision.DENIED("Unauthorized class")
        }
        
        // Check 2: Confidence Threshold
        if (target.confidence < roe.minConfidence) {
            return EngagementDecision.AWAIT_CONFIRMATION
        }
        
        // Check 3: Distance Limits
        if (target.distance > roe.maxDistance || 
            target.distance < roe.minDistance) {
            return EngagementDecision.DENIED("Out of range")
        }
        
        // Check 4: No-Fire Zones
        for (zone in roe.noFireZones) {
            if (zone.contains(target.geoLocation)) {
                return EngagementDecision.DENIED("No-fire zone")
            }
        }
        
        return EngagementDecision.AUTHORIZED
    }
}
```

### Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„ØªØµØ¹ÙŠØ¯ (Escalation Levels)
```kotlin
enum class EscalationLevel(val minConfidence: Float) {
    LEVEL_0_DETECTED(0.15f),      // ÙƒØ´Ù Ø£ÙˆÙ„ÙŠ
    LEVEL_1_TRACKED(0.35f),       // ØªØªØ¨Ø¹ Ù†Ø´Ø·
    LEVEL_2_CONFIRMED(0.55f),     // ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù‡ÙˆÙŠØ©
    LEVEL_3_LOCKED(0.75f),        // Ù‚ÙÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù
    LEVEL_4_AUTHORIZED(0.90f)     // ØªØµØ±ÙŠØ­ Ø¨Ø§Ù„Ø§Ø´ØªØ¨Ø§Ùƒ
}
```

### Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¥Ù„ØºØ§Ø¡ (Abort Logic)
```kotlin
class AbortController {
    
    fun checkAbortConditions(state: SystemState): AbortReason? {
        // Condition 1: Target Lost
        if (state.targetLostFrames > 30) {
            return AbortReason.TARGET_LOST
        }
        
        // Condition 2: Confidence Drop
        if (state.confidenceDelta < -0.3f) {
            return AbortReason.CONFIDENCE_DROP
        }
        
        // Condition 3: Sensor Failure
        if (!state.cameraActive || !state.imuActive) {
            return AbortReason.SENSOR_FAILURE
        }
        
        // Condition 4: Emergency Stop
        if (state.emergencyStopTriggered) {
            return AbortReason.EMERGENCY_STOP
        }
        
        // Condition 5: Entered No-Fire Zone
        if (state.inNoFireZone) {
            return AbortReason.NO_FIRE_ZONE
        }
        
        return null  // Continue engagement
    }
}
```

---

# Ø§Ù„ÙØµÙ„ 9: Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©

## 9.1 Smart Super Resolution (SSR)

### Ø§Ù„Ù…ÙˆØ§ØµÙØ§Øª
| Ø§Ù„Ù…Ø¹ÙŠØ§Ø± | Ø§Ù„Ù‚ÙŠÙ…Ø© |
|---------|--------|
| **Ø¯Ù‚Ø© Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø©** | 0.25 Ø¨ÙƒØ³Ù„ |
| **Ø­Ø¬Ù… Buffer** | 12 Ø¥Ø·Ø§Ø± |
| **Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯Ù…Ø¬** | Sigma-clipped MFSR |
| **Ù…Ø³ØªÙ‡Ø¯Ù** | Ø£Ù‡Ø¯Ø§Ù Ø¹Ù„Ù‰ Ø¨Ø¹Ø¯ 1 ÙƒÙ…+ |

### Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø©
```kotlin
class SmartSuperResolution {
    private val frameBuffer = ArrayDeque<Mat>(12)
    
    fun processFrame(frame: Mat): Mat? {
        frameBuffer.addLast(frame.clone())
        if (frameBuffer.size > 12) frameBuffer.removeFirst()
        
        if (frameBuffer.size < 4) return null
        
        // Sub-pixel alignment using phase correlation
        val alignedFrames = alignFrames(frameBuffer.toList())
        
        // Sigma-clipped fusion
        return fuseSigmaClipped(alignedFrames)
    }
    
    private fun alignFrames(frames: List<Mat>): List<Mat> {
        val reference = frames.last()
        return frames.map { frame ->
            val shift = phaseCorrelate(frame, reference)
            translateImage(frame, shift.x * 0.25, shift.y * 0.25)
        }
    }
}
```

---

## 9.2 Motion Detection Pipeline (6 Ù…Ø±Ø§Ø­Ù„)

### Ø§Ù„Ù…Ø±Ø§Ø­Ù„
```
Frame â†’ [1. Stabilization] â†’ [2. Background Model] â†’ [3. Foreground Mask]
      â†’ [4. Optical Flow] â†’ [5. Candidate Clustering] â†’ [6. AI Verification]
```

### 1. ØªØ«Ø¨ÙŠØª Ø§Ù„ØµÙˆØ±Ø© (Image Stabilization)
```kotlin
class ImageStabilizer {
    private val detector = FastFeatureDetector.create()
    
    fun stabilize(current: Mat, previous: Mat): Mat {
        // Detect FAST corners
        val prevPoints = MatOfKeyPoint()
        detector.detect(previous, prevPoints)
        
        // Track using Lucas-Kanade
        val currPoints = MatOfPoint2f()
        val status = MatOfByte()
        Video.calcOpticalFlowPyrLK(
            previous, current,
            prevPoints.toPoint2f(), currPoints,
            status, MatOfFloat()
        )
        
        // Estimate affine transform
        val transform = estimateAffinePartial2D(
            prevPoints.filtered(status),
            currPoints.filtered(status)
        )
        
        // Warp to stabilize
        val stabilized = Mat()
        warpAffine(current, stabilized, transform, current.size())
        return stabilized
    }
}
```

### 2. Ù†Ù…Ø°Ø¬Ø© Ø§Ù„Ø®Ù„ÙÙŠØ© (GMM Background Modeling)
```kotlin
class BackgroundModeler {
    private val mog2 = Video.createBackgroundSubtractorMOG2(
        500,    // history
        16.0,   // varThreshold
        false   // detectShadows
    )
    
    fun getForegroundMask(frame: Mat): Mat {
        // Downscale 4x for efficiency
        val small = Mat()
        resize(frame, small, Size(frame.width() / 4.0, frame.height() / 4.0))
        
        val mask = Mat()
        mog2.apply(small, mask)
        
        // Upscale mask back
        val fullMask = Mat()
        resize(mask, fullMask, frame.size())
        
        return fullMask
    }
}
```

### 3. Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ø¨ØµØ±ÙŠ (Optical Flow)
```kotlin
class MotionDetector {
    fun detectMotion(prev: Mat, curr: Mat, mask: Mat): List<MotionVector> {
        val flow = Mat()
        Video.calcOpticalFlowFarneback(
            prev, curr, flow,
            0.5, 3, 15, 3, 5, 1.2, 0
        )
        
        // Extract significant motion vectors
        val vectors = mutableListOf<MotionVector>()
        for (y in 0 until flow.rows() step 10) {
            for (x in 0 until flow.cols() step 10) {
                if (mask.get(y, x)[0] > 128) {
                    val flowVec = flow.get(y, x)
                    val magnitude = sqrt(flowVec[0].pow(2) + flowVec[1].pow(2))
                    if (magnitude > 2.0) {
                        vectors.add(MotionVector(x, y, flowVec[0], flowVec[1]))
                    }
                }
            }
        }
        return vectors
    }
}
```

---

## 9.3 Tiled Detection (Ø§Ù„ÙƒØ´Ù Ø§Ù„Ù…Ø¬Ø²Ø£)

### Ø§Ù„Ù‡ÙŠÙƒÙ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Tile 0    â”‚   Tile 1    â”‚
â”‚  (0,0)      â”‚  (w/2,0)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Tile 2    â”‚   Tile 3    â”‚
â”‚  (0,h/2)    â”‚  (w/2,h/2)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ø§Ù„ÙƒÙˆØ¯
```kotlin
class TiledDetector(private val detector: YOLODetector) {
    
    fun detectTiled(frame: Mat): List<Detection> {
        val w = frame.width()
        val h = frame.height()
        val allDetections = mutableListOf<Detection>()
        
        val tiles = listOf(
            Rect(0, 0, w/2, h/2),
            Rect(w/2, 0, w/2, h/2),
            Rect(0, h/2, w/2, h/2),
            Rect(w/2, h/2, w/2, h/2)
        )
        
        for (tile in tiles) {
            val crop = Mat(frame, tile)
            val detections = detector.detect(crop)
            
            // Remap coordinates to full frame
            detections.forEach { det ->
                det.box.x += tile.x
                det.box.y += tile.y
            }
            
            allDetections.addAll(detections)
        }
        
        return NMS(allDetections, iouThreshold = 0.45f)
    }
}
```

---

# Ø§Ù„ÙØµÙ„ 10: Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…

## 10.1 ByteTrack Algorithm

### Ø§Ù„Ø¨Ù†ÙŠØ©
```kotlin
class ByteTracker {
    private val tracks = mutableListOf<STrack>()
    private val lostTracks = mutableListOf<STrack>()
    private var frameId = 0
    
    fun update(detections: List<Detection>): List<STrack> {
        frameId++
        
        // Split detections by confidence
        val highConf = detections.filter { it.confidence >= 0.5f }
        val lowConf = detections.filter { it.confidence < 0.5f }
        
        // First association: high confidence with existing tracks
        val (matched1, unmatched1, unmatchedDets1) = 
            associate(tracks, highConf, iouThreshold = 0.7f)
        
        // Second association: remaining tracks with low confidence
        val remainingTracks = unmatched1
        val (matched2, unmatched2, _) = 
            associate(remainingTracks, lowConf, iouThreshold = 0.5f)
        
        // Update matched tracks
        for ((track, det) in matched1 + matched2) {
            track.update(det, frameId)
        }
        
        // Mark unmatched as lost
        for (track in unmatched2) {
            track.markLost()
            if (track.lostFrames > 30) {
                tracks.remove(track)
            }
        }
        
        // Create new tracks from unmatched high-conf detections
        for (det in unmatchedDets1) {
            tracks.add(STrack(det, frameId))
        }
        
        return tracks.filter { it.isActivated }
    }
}
```

---

## 10.2 Kalman Filter Ù„Ù„ØªØªØ¨Ø¹

### Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø©
```
State Vector: [x, y, w, h, vx, vy, vw, vh]

Prediction:
  x' = x + vx Ã— dt
  y' = y + vy Ã— dt
  w' = w + vw Ã— dt
  h' = h + vh Ã— dt

Update:
  K = P Ã— H' Ã— (H Ã— P Ã— H' + R)â»Â¹
  x = x + K Ã— (z - H Ã— x)
  P = (I - K Ã— H) Ã— P
```

### Ø§Ù„ØªÙ†ÙÙŠØ°
```kotlin
class KalmanTracker {
    private val kf = KalmanFilter(8, 4, 0, CvType.CV_32F)
    
    init {
        // Transition matrix (constant velocity model)
        kf.transitionMatrix = Mat.eye(8, 8, CvType.CV_32F).apply {
            put(0, 4, 1.0)  // x += vx
            put(1, 5, 1.0)  // y += vy
            put(2, 6, 1.0)  // w += vw
            put(3, 7, 1.0)  // h += vh
        }
        
        // Measurement matrix
        kf.measurementMatrix = Mat.zeros(4, 8, CvType.CV_32F).apply {
            put(0, 0, 1.0)
            put(1, 1, 1.0)
            put(2, 2, 1.0)
            put(3, 3, 1.0)
        }
    }
    
    fun predict(): RectF {
        val prediction = kf.predict()
        return RectF(
            prediction[0, 0][0].toFloat(),
            prediction[1, 0][0].toFloat(),
            prediction[2, 0][0].toFloat(),
            prediction[3, 0][0].toFloat()
        )
    }
    
    fun update(measurement: RectF) {
        val meas = Mat(4, 1, CvType.CV_32F)
        meas.put(0, 0, measurement.left.toDouble())
        meas.put(1, 0, measurement.top.toDouble())
        meas.put(2, 0, measurement.width().toDouble())
        meas.put(3, 0, measurement.height().toDouble())
        kf.correct(meas)
    }
}
```

---

## 10.3 Re-ID Ø¨Ø§Ù„Ø£Ù„ÙˆØ§Ù†

### Color Histogram Signature
```kotlin
class ColorReIDEngine {
    
    fun extractSignature(image: Mat, box: Rect): FloatArray {
        val roi = Mat(image, box)
        
        // Convert to HSV
        val hsv = Mat()
        Imgproc.cvtColor(roi, hsv, Imgproc.COLOR_BGR2HSV)
        
        // Calculate histogram
        val hist = Mat()
        val channels = MatOfInt(0, 1)  // H and S channels
        val histSize = MatOfInt(30, 32)
        val ranges = MatOfFloat(0f, 180f, 0f, 256f)
        
        Imgproc.calcHist(
            listOf(hsv), channels, Mat(),
            hist, histSize, ranges
        )
        
        Core.normalize(hist, hist)
        
        return hist.toFloatArray()
    }
    
    fun compareSignatures(sig1: FloatArray, sig2: FloatArray): Float {
        // Bhattacharyya distance
        var sum = 0.0
        for (i in sig1.indices) {
            sum += sqrt(sig1[i].toDouble() * sig2[i].toDouble())
        }
        return sum.toFloat()
    }
}
```

---

# Ù…Ù„Ø­Ù‚ Ù‡Ù€: Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©

## Ù…Ù„ÙØ§Øª Ø§Ù„ÙƒØ´Ù ÙˆØ§Ù„ØªØªØ¨Ø¹
| Ø§Ù„Ù…Ù„Ù | Ø§Ù„ÙˆØ¸ÙŠÙØ© |
|-------|---------|
| `YOLODetector.kt` | ÙƒØ´Ù Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ù€ YOLOv8 |
| `ByteTracker.kt` | ØªØªØ¨Ø¹ ByteTrack |
| `STrack.kt` | ÙƒØ§Ø¦Ù† Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ÙØ±Ø¯ÙŠ |
| `ObjectTracker.kt` | Kalman Filter Tracker |
| `StableTracker.kt` | ØªØªØ¨Ø¹ Ù…Ø³ØªÙ‚Ø± Ù…Ø¹ Grace Period |
| `TrackValidator.kt` | Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª |
| `TargetPrioritizer.kt` | ØªØ±ØªÙŠØ¨ Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø£Ù‡Ø¯Ø§Ù |

## Ù…Ù„ÙØ§Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©
| Ø§Ù„Ù…Ù„Ù | Ø§Ù„ÙˆØ¸ÙŠÙØ© |
|-------|---------|
| `SmartSuperResolution.kt` | ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¯Ù‚Ø© |
| `ImageStabilizer.kt` | ØªØ«Ø¨ÙŠØª Ø§Ù„ØµÙˆØ±Ø© |
| `BackgroundModeler.kt` | Ù†Ù…Ø°Ø¬Ø© Ø§Ù„Ø®Ù„ÙÙŠØ© |
| `MotionDetector.kt` | ÙƒØ´Ù Ø§Ù„Ø­Ø±ÙƒØ© |
| `CandidateGenerator.kt` | ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø±Ø´Ø­ÙŠÙ† |
| `CandidateVerifier.kt` | Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø±Ø´Ø­ÙŠÙ† |
| `WhiteRectangleDetector.kt` | ÙƒØ´Ù Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„Ø§Øª Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡ |

## Ù…Ù„ÙØ§Øª Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
| Ø§Ù„Ù…Ù„Ù | Ø§Ù„ÙˆØ¸ÙŠÙØ© |
|-------|---------|
| `SharedBusManager.kt` | Ø¥Ø¯Ø§Ø±Ø© USB/Serial |
| `CANServoProtocol.kt` | Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ CAN |
| `UnifiedProtocol.kt` | Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ 5-Byte |
| `TelemetryStreamer.kt` | Ø¨Ø« Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª 73-byte |
| `KcaParser.kt` | ØªØ­Ù„ÙŠÙ„ GPS Ø®Ø§Ø±Ø¬ÙŠ |
| `SerialGpsService.kt` | Ø®Ø¯Ù…Ø© GPS Serial |

## Ù…Ù„ÙØ§Øª Ø§Ù„Ø¯Ù…Ø¬ Ø§Ù„Ø¹Ø³ÙƒØ±ÙŠ
| Ø§Ù„Ù…Ù„Ù | Ø§Ù„ÙˆØ¸ÙŠÙØ© |
|-------|---------|
| `SensorFusionLayer.kt` | Ø¯Ù…Ø¬ Ø§Ù„Ø­Ø³Ø§Ø³Ø§Øª |
| `TrackFusionLayer.kt` | Ø¯Ù…Ø¬ Ø§Ù„ØªØªØ¨Ø¹ |
| `DecisionFusionLayer.kt` | Ø¯Ù…Ø¬ Ø§Ù„Ù‚Ø±Ø§Ø± |
| `DecisionAuthority.kt` | Ø³Ù„Ø·Ø© Ø§Ù„Ù‚Ø±Ø§Ø± |

---

# Ù…Ù„Ø­Ù‚ Ùˆ: Ù…Ø³Ø±Ø¯ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª

| Ø§Ù„Ù…ØµØ·Ù„Ø­ | Ø§Ù„ØªØ¹Ø±ÙŠÙ |
|---------|---------|
| **ByteTrack** | Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ØªØªØ¨Ø¹ ØªØ³ØªØ®Ø¯Ù… Ø§Ù„ÙƒØ´ÙˆÙØ§Øª Ù…Ù†Ø®ÙØ¶Ø© Ø§Ù„Ø«Ù‚Ø© |
| **Coasting** | Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø¨Ø§Ù„ØªØªØ¨Ø¹ Ø¨Ø¯ÙˆÙ† ÙƒØ´Ù Ø¬Ø¯ÙŠØ¯ |
| **DTR** | Data Terminal Ready - Ø¥Ø´Ø§Ø±Ø© ØªØ­ÙƒÙ… Serial |
| **FPS** | Frames Per Second - Ø¥Ø·Ø§Ø±Ø§Øª ÙÙŠ Ø§Ù„Ø«Ø§Ù†ÙŠØ© |
| **GMM** | Gaussian Mixture Model - Ù†Ù…ÙˆØ°Ø¬ Ø®Ù„ÙŠØ· ØºØ§ÙˆØ³ÙŠ |
| **Grace Period** | ÙØªØ±Ø© Ø§Ù„Ø³Ù…Ø§Ø­ Ù‚Ø¨Ù„ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„Ù‡Ø¯Ù |
| **HUD** | Head-Up Display - Ø´Ø§Ø´Ø© Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù„ÙˆÙŠØ© |
| **IoU** | Intersection over Union - ØªÙ‚Ø§Ø·Ø¹ Ø¹Ù„Ù‰ Ø§ØªØ­Ø§Ø¯ |
| **Kalman Filter** | Ù…Ø±Ø´Ø­ Ù„Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ© |
| **MFSR** | Multi-Frame Super Resolution |
| **NMS** | Non-Maximum Suppression - ÙƒØ¨Øª ØºÙŠØ± Ø§Ù„Ø£Ù‚ØµÙ‰ |
| **NPU** | Neural Processing Unit - ÙˆØ­Ø¯Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹ØµØ¨ÙŠØ© |
| **Optical Flow** | Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ø¨ØµØ±ÙŠ - ØªØªØ¨Ø¹ Ø­Ø±ÙƒØ© Ø§Ù„Ø¨ÙƒØ³Ù„Ø§Øª |
| **Re-ID** | Re-Identification - Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹Ø±ÙŠÙ |
| **ROE** | Rules of Engagement - Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ¨Ø§Ùƒ |
| **RTS** | Request To Send - Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ |
| **SSR** | Smart Super Resolution |
| **UVB** | Unified Virtual Bus - Ø§Ù„Ù†Ø§Ù‚Ù„ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø§Ù„Ù…ÙˆØ­Ø¯ |
| **VID** | Vendor ID - Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø±ÙƒØ© Ø§Ù„Ù…ØµÙ†Ø¹Ø© |
| **YOLOv8** | You Only Look Once v8 - Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ÙƒØ´Ù |

---

# Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¯Ù„ÙŠÙ„

**Ø§Ù„Ø¥ØµØ¯Ø§Ø±**: 2.0 (Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø´Ø§Ù…Ù„)  
**Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«**: 2026-01-12  
**Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª**: ~1500 Ø³Ø·Ø±  
**Ø§Ù„Ù…Ø¤Ù„Ù**: SAQR Seeker Development Team

---

> **Ù…Ù„Ø§Ø­Ø¸Ø©**: Ù‡Ø°Ø§ Ø§Ù„Ø¯Ù„ÙŠÙ„ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø®Ø±Ø¬Ø§Øª ÙˆØ§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„Ø§Øª ÙˆØ§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© ÙÙŠ Ù†Ø¸Ø§Ù… SAQR Seeker / CANphon. Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ©ØŒ Ø±Ø§Ø¬Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…ØµØ¯Ø±ÙŠ ÙÙŠ Ù…Ø¬Ù„Ø¯ `app/src/main/java/com/example/canphon/`.
